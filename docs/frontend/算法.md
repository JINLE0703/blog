---
title: 算法
lang: zh-CN
---

## 算法思想

### 分而治之

它将一个问题分成多个和原问题相似的小问题，递归解决小问题，再将结果合并以解决原来的问题。

##### 应用场景

猜数字大小（leetcode374）、翻转二叉树（leetcode226）、相同的树（leetcode100）、对称二叉树（leetcode101）

### 动态规划

将一个问题分解为相互重叠的子问题，通过反复求解子问题，来解决原来问题。

#### 爬楼梯

题目描述：假设楼梯一共有 n 层。每次只能爬 1 步 或 2 步，问有多少种爬到楼顶的方法

```js
const climbStairs = function(n) {
    // 初始化结果数组
    const f = [];
    f[1] = 1;
    f[2] = 2;
    // 动态更新每一层楼梯对应的结果
    for(let i = 3;i <= n;i++){
        f[i] = f[i-2] + f[i-1];
    }
    return f[n];
};
```

#### 零钱兑换

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

```js
var coinChange = function (coins, amount) {
  if (amount === 0) {
    return 0;
  }
  const dp = new Array(amount + 1).fill(Number.MAX_VALUE);
  dp[0] = 0;
  // 遍历 [1, amount] 这个区间的硬币总额
  for (let i = 1; i < dp.length; i++) {
    // 循环遍历每个可用硬币的面额
    for (let j = 0; j < coins.length; j++) {
      if (i - coins[j] >= 0) {
        dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
      }
    }
  }
  return dp[amount] === Number.MAX_VALUE ? -1 : dp[amount];
};
```

##### 应用场景

斐波那契数列、爬楼梯（leetcode70）、打家劫舍（leetcode198）

### 贪心算法

期盼通过每个阶段的局部最优选择，从而达到全局的最优，结果不一定最优。

##### 应用场景

分饼干（leetcode455）、买卖股票的最佳时机（leetcode122）

### 回溯算法

一种渐进式寻找并构建解决方式的策略。

先从一个可能的动作开始解决问题，如果不行，就回溯并选择另一个动作，直到问题解决。

##### 应用场景

全排列（leetcode46）、子集（leetcode78）

## 常用算法

### 排序

#### 冒泡排序

时间复杂度 O(n^2)

```
比较所有相邻元素，如果第一个比第二个大，则交换

一轮下来可以保证最后一个数是最大的

执行 n-1 轮，就可以完成排序
```

```js
Array.prototype.bubbleSort = function () {
  for (let i = 0; i < this.length - 1; i++) {
    for (let j = 0; j < this.length - 1 - i; j++) {
      if (this[j] > this[j + 1]) {
        const temp = this[j]
        this[j] = this[j + 1]
        this[j + 1] = temp
      }
    }
  }
}
```

#### 选择排序

时间复杂度 O(n^2)

```
找到数组中的最小值，选中它并将其放置在第一位

接着找第二小的值，选中它并将其放置在第二位

...
```

```js
Array.prototype.selectionSort = function () {
  for (let i = 0; i < this.length - 1; i++) {
    let minIndex = i
    for (let j = i + 1; j < this.length; j++) {
      if (this[j] < this[minIndex]) {
        minIndex = j
      }
    }
    if (i !== minIndex) {
      const temp = this[i]
      this[i] = this[minIndex]
      this[minIndex] = temp
    }
  }
}
```

#### 插入排序

时间复杂度 O(n^2)

```
从第二个数开始往前比

比它大就往后排

以此类推进行到最后一个数
```

```js
Array.prototype.insertionSort = function () {
  for (let i = 1; i < this.length; i++) {
    const temp = this[i]
    let j = i
    // 判断 j 前面一个元素是否比 temp 大
    while (j > 0 && this[j - 1] > temp) {
      // 如果是，则将 j 前面的一个元素后移一位，为 temp 让出位置
      this[j] = this[j - 1]
      j--
    }
    this[j] = temp
  }
}
```

#### 归并排序

时间复杂度 O(nlogn)

```
分：把数组劈成两半，再递归对子数组进行“分”操作，直到分成一个个单独的数

合：把两个数合并为有序数组，再对有序数组进行合并，直到全部子数组合并为一个完整数组
	- 新建一个空数组 res，用于存放最终排序后的数组
	- 比较两个有序数组的头部，较小者出队并推入 res
	- 如果两个数组还有值，重复第二步
```

```js
Array.prototype.mergeSortSort = function () {
  const rec = (arr) => {
    if (arr.length === 1) { return arr }
    const mid = Math.floor(arr.length / 2)
    const left = arr.slice(0, mid)
    const right = arr.slice(mid, arr.length)
    const orderLeft = rec(left)
    const orderRight = rec(right)
    const res = []
    while (orderLeft.length || orderRight.length) {
      if (orderLeft.length && orderRight.length) {
        res.push(orderLeft[0] < orderRight[0] ? orderLeft.shift() : orderRight.shift())
      } else if (orderLeft.length) {
        res.push(orderLeft.shift())
      } else if (orderRight.length) {
        res.push(orderRight.shift())
      }
    }
    return res
  }
  const res = rec(this)
  res.forEach((value, index) => { this[index] = value })
}
```

##### 应用场景

合并两个有序链表（leetcode21）

#### 快速排序

时间复杂度 O(nlogn)

```
分区：从数组中任选一个“基准”，所有比基准小的元素放在基准前面，比基准大的放在基准后面

递归：递归地对基准前后的子数组进行分区
```

```js
Array.prototype.quickSort = function () {
  const rec = (arr) => {
    if (arr.length === 1) { return arr }
    const left = []
    const right = []
    const mid = arr[0]
    for (let i = 1; i < arr.length; i++) {
      if (arr[i] < mid) {
        left.push(arr[i])
      } else {
        right.push(arr[i])
      }
    }
    return res = [...rec(left), mid, ...rec(right)]
  }
  const res = rec(this)
  res.forEach((v, i) => { this[i] = v })
}
```

```js
// 快速排序入口
function quickSort(arr, left = 0, right = arr.length - 1) {
  // 定义递归边界，若数组只有一个元素，则没有排序必要
  if(arr.length > 1) {
      // lineIndex表示下一次划分左右子数组的索引位
      const lineIndex = partition(arr, left, right)
      // 如果左边子数组的长度不小于1，则递归快排这个子数组
      if(left < lineIndex-1) {
        // 左子数组以 lineIndex-1 为右边界
        quickSort(arr, left, lineIndex-1)
      }
      // 如果右边子数组的长度不小于1，则递归快排这个子数组
      if(lineIndex<right) {
        // 右子数组以 lineIndex 为左边界
        quickSort(arr, lineIndex, right)
      }
  }
  return arr
}
// 以基准值为轴心，划分左右子数组的过程
function partition(arr, left, right) {
  // 基准值默认取中间位置的元素
  let mid = arr[Math.floor(left + (right-left)/2)]
  // 初始化左右指针
  let i = left
  let j = right
  // 当左右指针不越界时，循环执行以下逻辑
  while(i<=j) {
      // 左指针所指元素若小于基准值，则右移左指针
      while(arr[i] < mid) {
          i++
      }
      // 右指针所指元素大于基准值，则左移右指针
      while(arr[j] > mid) {
          j--
      }

      // 若i<=j，则意味着基准值左边存在较大元素或右边存在较小元素，交换两个元素确保左右两侧有序
      if(i<=j) {
          swap(arr, i, j)
          i++
          j--
      }
  }
  // 返回左指针索引作为下一次划分左右子数组的依据
  return i
}

// 快速排序中使用 swap 的地方比较多，我们提取成一个独立的函数
function swap(arr, i, j) {
  [arr[i], arr[j]] = [arr[j], arr[i]]
}
```

### 搜索

#### 顺序搜索

时间复杂度 O(n)

```
遍历数组

找到跟目标相等的元素，就返回下标

遍历结束没找到就返回 -1
```

```js
Array.prototype.sequentialSearch = function (item) {
  for (let i = 1; i < this.length; i++) {
    if (this[i] === item) {
      return i
    }
  }
  return -1
}
```

#### 二分搜索

时间复杂度 O(logn)

```
从数组的中间元素开始，如果中间元素正好是目标值，则搜索结束

如果目标值大于或小于中间值，则在大于或小于中间元素的那一半数组中搜索
```

```js
Array.prototype.binarySearch = function (item) {
  let low = 0
  let high = item.length - 1
  while (low <= high) {
    const mid = Math.floor((low + high) / 2)
    if (this[mid] === item) {
      return mid
    } else if (this[mid] < item) {
      low = mid + 1
    } else {
      high = mid - 1
    }
  }
  return -1
}
```

##### 平方根函数

计算并返回 x 的平方根，其中 x 是非负整数

由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去

leetcode：[https://leetcode-cn.com/problems/sqrtx/](https://leetcode-cn.com/problems/sqrtx/)

```js
var mySqrt = function (x) {
  if (x < 2) return x
  let left = 0
  let right = Math.floor(x / 2)
  while (left <= right) {
    let mid = Math.floor((right - left) / 2 + left)
    if (mid * mid === x) return mid
    if (mid * mid < x) left = mid + 1
    if (mid * mid > x) right = mid - 1
  }
  return right
};
```

##### 应用场景

猜数字大小（leetcode374）

### Dijkstra（迪杰斯特拉）算法

图算法，解决有权图从一个节点到其他节点的最短路径问题

1. 初始化两个集合（S，S 为只有初始顶点点 A 的集合，U 为其他顶点集合）
2. 如果 U 不为空， 对 U 集合顶点进行距离的排序，并取出距离 A 最近的一个顶点 D
   1. 将顶点 D 的纳入 S 集合
   2. 更新通过顶点 D 到达 U 集合所有点的距离（如果距离更小则更新，否则不更新）
   3. 重复 2 步骤
3. 知道 U 集合为空

### LRU 缓存机制

- `LRUCache(int capacity)` 以正整数作为容量 `capacity` 初始化 LRU 缓存
- `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 -1 
- `void put(int key, int value)` 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间

leetcode：[https://leetcode-cn.com/problems/lru-cache/](https://leetcode-cn.com/problems/lru-cache/)

#### 思路

- 写入数据时：
  - 之前就有的，更新数据，刷新位置
  - 之前没有的，有位置就直接写入，没有位置，就先删掉最久没有使用的条目，再写入
- 数据结构：
  - 哈希表：实现数据快速查找 *O(1)*
    - key：存双向链表的 key
    - value：链表节点引用
  - 双向链表：存 key 和 value，结点有前驱指针，删除和移动节点都是指针的变动，都是 *O(1)*

#### 解题

1. 定义 ListNode

   ```js
   class ListNode {
     constructor(key, value) {
       this.key = key     
       this.value = val
       this.next = null
       this.prev = null
     }
   }
   ```

2. 定义 LRUCache

   ```js
   class LRUCache {
     constructor(capacity) {     
       this.capacity = capacity  // 缓存的容量
       this.hash = {}            // 哈希表
       this.count = 0            // 缓存数目
       this.dummyHead = new ListNode() // 虚拟头结点
       this.dummyTail = new ListNode() // 虚拟尾节点
       this.dummyHead.next = this.dummyTail
       this.dummyTail.prev = this.dummyHead // 相联系
     }
   }
   ```

   `dummyHead` 和 `dummyTail` 是虚拟头尾节点，方便操作

3. get 方法

   ```js
   get(key) {
     let node = this.hash[key]      // 从哈希表中，获取对应的节点
     if (node == null) return -1    // 如果节点不存在，返回-1
     this.moveToHead(node)          // 被读取了，该节点移动到链表头部
     return node.value              // 返回出节点值
   }
   ```

   ```js
   moveToHead(node) {         
     this.removeFromList(node) // 从链表中删除节点
     this.addToHead(node)      // 添加到链表的头部
   }
   removeFromList(node) {        
     let temp1 = node.prev     // 暂存它的后继节点
     let temp2 = node.next     // 暂存它的前驱节点
     temp1.next = temp2        // 前驱节点的next指向后继节点
     temp2.prev = temp1        // 后继节点的prev指向前驱节点
   }
   addToHead(node) {                 // 插入到虚拟头结点和真实头结点之间
     node.prev = this.dummyHead      // node的prev指针，指向虚拟头结点
     node.next = this.dummyHead.next // node的next指针，指向原来的真实头结点
     this.dummyHead.next.prev = node // 原来的真实头结点的prev，指向node
     this.dummyHead.next = node      // 虚拟头结点的next，指向node
   }
   ```

4. put 方法

   ```js
   put(key, value) {
     let node = this.hash[key]            // 获取链表中的node
     if (node == null) {                  // 不存在于链表，是新数据
       if (this.count == this.capacity) { // 容量已满
         this.removeLRUItem()             // 删除最远一次使用的数据
       }
       let newNode = new ListNode(key, value) // 创建新的节点
       this.hash[key] = newNode          // 存入哈希表
       this.addToHead(newNode)           // 将节点添加到链表头部
       this.count++                      // 缓存数目+1
     } else {                   // 已经存在于链表，老数据
       node.value = value       // 更新value
       this.moveToHead(node)    // 将节点移到链表头部
     }
   }
   ```

   ```js
   removeLRUItem() {               // 删除“老家伙”
     let tail = this.popTail()     // 将它从链表尾部删除
     delete this.hash[tail.key]    // 哈希表中也将它删除
     this.count--                  // 缓存数目-1
   }
   popTail() {                      // 删除链表尾节点
     let tail = this.dummyTail.prev // 通过虚拟尾节点找到它
     this.removeFromList(tail)      // 删除该真实尾节点
     return tail                    // 返回被删除的节点
   }
   ```

### DFS 二叉树深度

输入一棵二叉树的根节点，求该树的深度

leetcode：[https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/](https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/)

```js
var maxDepth = function (root) {
  if (!root) { return 0; }
  return dfs(root, 0);

  function dfs(root, deep) {
    if (!root) { return deep; }
    deep++;
    return Math.max(dfs(root.left, deep), dfs(root.right, deep));
  }
};
```

### BFS 二叉树层序遍历

给你一个二叉树，请你返回其按 **层序遍历** 得到的节点值。 （即逐层地，从左到右访问所有节点）

leetcode：[https://leetcode-cn.com/problems/binary-tree-level-order-traversal/](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

```js
var levelOrder = function(root) {
  if(!root) return []

  const queue = [root]
  const res = []
  
  while(queue.length) {
    let len = queue.length
    let arr = [] // 临时存放
    // 同一层级一次性出队
    while(len--) {
      const n = queue.shift()
      arr.push(n.val)
      if(n.left) queue.push(n.left)
      if(n.right) queue.push(n.right)
    }
    res.push(arr)
  }

  return res
};
```

### 判断有效数独

题目：判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。

- 数字 1-9 在每一行只能出现一次。
- 数字 1-9 在每一列只能出现一次。
- 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。

leetcode：[https://leetcode-cn.com/problems/valid-sudoku/](https://leetcode-cn.com/problems/valid-sudoku/)

#### 思路

1. 设置三元素：
   1. `row`：存放 1-9 横排的值
   2. `col`：存放 1-9 纵排的值
   3. `box`：存放 1-9 小盒子的值
   4. 均设置为空数组
2. 顺序遍历存放值
   1. 通过双重 `for` 遍历
   2. `row[i]` 存放对应横坐标的值
   3. `col[j]` 存放对应纵坐标的值
   4. `box[boxIndex]` 存放对应小盒子的值
3. 判断 boxIndex
   1. `Math.floor(j / 3)` 可以控制 3 * 9 宫格时盒子的序号
   2. `Math.floor(i / 3) * 3` 再通过相加对应的值即可获取盒子序号
   3. `boxIndex = Math.floor(i / 3) * 3 + Math.floor(j / 3)`

```js
var isValidSudoku = function (board) {
  let row = []
  let col = []
  let box = []
  for (let i = 0; i < 9; i++) {
    row[i] = []
    col[i] = []
    box[i] = []
  }

  for (let i = 0; i < 9; i++) {
    for (let j = 0; j < 9; j++) {
      let val = board[i][j]
      if (val !== '.') {
        if (!row[i].includes(val)) {
          row[i].push(val)
        } else {
          return false
        }

        if (!col[j].includes(val)) {
          col[j].push(val)
        } else {
          return false
        }

        const boxIndex = Math.floor(i / 3) * 3 + Math.floor(j / 3); // 对应的盒子
        if (!box[boxIndex].includes(val)) {
          box[boxIndex].push(val)
        } else {
          return false
        }
      }
    }
  }
  return true
};
```

