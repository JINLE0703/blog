---
title: 计算机网络
lang: zh-ji
---

## 基础

### 层次结构

#### OSI 七层模型

- 应用层 --- 为计算机用户提供接口和服务
- 表示层 --- 数据处理（编码解码、加密解密等）
- 会话层 --- 管理（建立、维护、重连）通信会话
- 传输层 --- 管理端到端的通信连接
- 网络层 --- 数据路由（决定数据在网络的路径）
- 数据链路层 --- 管理相邻节点之间的数据通信
- 物理层 --- 数据通信的光电物理特性

#### TCP/IP 四层模型

- 应用层（应用层、表示层、会话层）（HTTP/FTP...）
- 传输层（TCP/UDP）
- 网络层（IP/ICMP）
- 网络接口层（数据链路层、物理层）

### 网络层

#### IP 协议

IP 是整个 TCP/IP 协议族的核心，也是构成互联网的基础。IP 位于 TCP/IP 模型的网络层（相当于 OSI 模型的网络层），对上可载送传输层各种协议的信息，例如 TCP、UDP 等；对下可将 IP 信息包放到链路层，通过以太网、令牌环网络等各种技术来传送。

- 使得复杂的实际网络变为一个虚拟互连的网络
- 使得网络层可以屏蔽底层细节而专注网络层的数据转发
- 解决了在虚拟网络中数据报传输路径的问题

> 详情见下文 [IP 协议](#ip-协议-2)

#### (R)ARP 协议

ARP 协议 --- 地址解析协议，把网络层 IP 地址 解析为 数据链路层 MAC 地址

RARP 协议 --- 逆地址解析协议

ARP 缓存表 ---缓存了 IP 地址到硬件地址之间的映射关系（有期限），判断缓存表有没有映射关系而决定数据链路层的传输方式

#### 网络地址转换 NAT 技术

用于多个主机通过一个公有 IP 访问互联网的私有网络中

NAT 减缓了 IP 地址的消耗，但是增加了网络通信的复杂度

通过把内部地址映射到外部网络的一个 IP 地址的不同**端口**上

#### ICMP 协议

用于**报告错误信息或者异常情况**，此协议报文封装在 IP 数据报文里

可分为 **差错报告报文** 和 **询问报文**

#### 自治系统(AS)

处于一个管理机构下的网络设备群，AS 内部网络自行管理， AS 对外提供一个或者多个出（入）口

自治系统内部路由的协议称为**内部网关协议（RIP 、 OSPF）**，外部路由的协议称为：**外部网关协议（BGP）**

#### RIP 协议

使用 DV 算法的一种路由协议

协议把网络的 **跳数** 作为 DV 算法的距离，每隔 30s 交换一次路由信息，跳数 >15 的路由则为不可达路由

#### OSPF 协议

开放最短路径优先协议，其核心是 **Dijkstra 算法**

其特点为：

- 向所有的路由器发送消息（Dijkstra 算法）
- 消息描述该路由器与相邻路由器的链路状态
- 只有链路状态发生变化时，才发送更新信息

#### BGP 协议

边际网关协议，能够找到一条到达目的**比较好**的路由

AS 之间通过 **BGP 发言人** 来进行路由信息的交换

### 数据链路层

#### 封装成帧

发送端在网络层的一段数据前后添加特定标记形成“帧”

![](https://raw.githubusercontent.com/jinle0703/img-host/master/blog/%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7.png)

#### 透明传输

对控制字符（帧头、帧尾）转义

#### 差错检测

- 奇偶校验码
- 循环冗余校验码 CRC --- 根据传输或保存的数据而**产生固定位数校验码**

> 数据链路层只进行数据的检测，不进行纠正

#### MTU

最大传输单元，数据链路层的数据帧也不是无限大的

**路径 MTU** 由链路中 MTU 的最小值决定

#### MAC 地址

物理地址、硬件地址，每个设备都拥有唯一的 MAC 地址

MAC 地址共48位，使用十六进制表示，如 `30-B4-9E-ED-85-CA`

#### 以太网协议

完成 **相邻设备** 的数据帧传输

1. 发送端通过网卡发出数据帧
2. 数据帧到达路由器，路由器取出前 6 字节（接收端 MAC 地址）
3. 路由器匹配 MAC 地址表，找到相应网络接口
4. 路由器往该接口发送数据帧
5. 如果路由器匹配不到相应 MAC 地址，则广播数据包到除发送端以外的端口，并将收到回应记录在 MAC 地址表

### 物理层

为了连接不同的物理设备，传输比特流（高低电平、数字信号）

#### 信道

往一个方向传送信息的媒体，一条通信电路包含一个接收信道和一个发送信道

- 单工通信信道 --- 只能一个方向通信，没有反方向反馈的信道
- 半双工通信信道 --- 双方都可以发送和接收信息，不能双方同时发送，也不能同时接收
- 全双工通信信道 --- 双方都可以同时发送和接收信息

#### 分用-复用技术

## HTTP

### 状态码

#### 分类

- 1xx：服务器收到请求，正在处理
- 2xx：请求成功
- 3xx：需要进行附加操作（重定向）
- 4xx：客户端错误
- 5xx：服务端错误

#### 常用状态码

- 200 成功
- 204 请求成功，没有资源返回
- 206 客户端进行范围请求，服务端成功执行这部分请求
- 301 永久重定向（配合location，浏览器自动处理）（如：换域名）
- 302 临时重定向（配合location，浏览器自动处理）（网站维护）
- 304 资源未被修改
- 400 客户端请求报文语法错误
- 401 客户端认证身份失败
- 403 没有权限
- 404 资源未找到
- 500 服务器错误
- 503 服务器超负载或停机维护
- 504 网关超时

### Restful API

传统 API 设计：把每个 url 当做一个功能

Restful API 设计：把每个 url 当做一个唯一的资源

### 首部字段

#### 通用首部

`Cache-Control`：控制缓存的行为

指令的参数是可选的，多个指令之间通过“,”分隔。

```
Cache-Control: private, max-age=0, no-cache
```

|      请求指令      |  参数  |             说明             |
| :----------------: | :----: | :--------------------------: |
|      no-cache      |   无   |    强制向源服务器再次验证    |
|      no-store      |   无   |  不缓存请求或响应的任何内容  |
|   max-age = [秒]   |  必需  |      响应的最大 Age 值       |
| max-stale( = [秒]) | 可省略 |       接收已过期的响应       |
|  min-fresh = [秒]  |  必需  | 期望在指定时间内的响应仍有效 |
|    no-transform    |   无   |     代理不可更改媒体类型     |
|   only-if-cached   |   无   |        从缓存获取资源        |
|  cache-extension   |        |     新指令标记（token）      |

|     响应指令     |  参数  |                      说明                      |
| :--------------: | :----: | :--------------------------------------------: |
|      public      |   无   |            可向任意方提供响应的缓存            |
|     private      | 可省略 |              仅向特定用户返回响应              |
|     no-cache     | 可省略 |            缓存前必须先确认其有效性            |
|     no-store     |   无   |           不缓存请求或响应的任何内容           |
|   no-transform   |   无   |              代理不可更改媒体类型              |
| must-revalidate  |   无   |        可缓存但必须再向源服务器进行确认        |
| proxy-revalidate |   无   | 要求中间缓存服务器对缓存的响应有效性再进行确认 |
|  max-age = [秒]  |  必需  |               响应的最大 Age 值                |
| s-maxage = [秒]  |  必需  |        公共缓存服务器响应的最大 Age 值         |
| cache-extension  |        |              新指令标记（token）               |

`Connection`：控制不再转发给代理的首部字段、管理持久连接

```
Connection: Keep-Alive
```

`Date`：创建报文的日期时间

`Pragma`：HTTP/1.1 之前版本的历史遗留字段

`Trailer`：报文末端的首部一览

`Transfer-Encoding`：指定报文主体的传输编码方式

`Upgrade`：升级为其他协议，使用时需指定 `Connection:Upgrade`

`Via`：代理服务器的相关信息，用于追踪客户端与服务器之间的请求和响应报文的传输路径

`Warning`：错误通知

```
Warning: [警告码][警告的主机:端口号]“[警告内容]”([日期时间])
```

#### 请求首部

`Accept`：用户代理可处理的媒体类型

```
Accept: text/html, application/xhtml+xml, application/xml;q=0.9, */*;q=0.8
```

`Accept-Charset`：优先的字符集

`Accept-Encoding`：浏览器可接收的压缩算法，如 gzip

`Accept-Languange`：浏览器可接收的语言，如 zh-CN

`Authorization`：Web 认证信息，用于告知服务器用户代理的认证信息

通常，想要通过服务器认证的用户代理会在接收到返回的 401 状态码响应后，把首部字段 `Authorization` 加入请求中。

`Expect`：期待服务器的特定行为

`From`：用户的电子邮箱地址

`Host`：域名，告知服务器请求的资源所处的互联网主机名和端口号。

`If-Match`：比较实体标记（ETag），当 `If-Match` 和 `ETag` 的值一样时服务器才会接收请求

`If-Modified—Since`：比较资源更新时间（Last-Modified），若 `If-Modified—Since` 时间在资源更新时间之前，则希望服务器处理请求返回资源，若 `If-Modified—Since` 时间在资源更新时间之后，则直接返回 304

`If-None-Match`：比较实体标记（ETag），`If-None-Match` 和 `ETag` 不一致时（说明已更新），服务器处理请求返回资源

`If-Range`：资源未更新时发送实体 Byte 的范围请求

`If-Unmodified-Since`：比较资源的更新时间（与 If-Modified-Since 相反）

`Max-Forwards`：最大传输逐跳数

`Proxy-Authorization`：代理服务器要求客户端的认证信息

`Range`：实体的字节范围请求

`Referer`：对请求中 URI 的原始获取方

`TE`：传输编码的优先级

`User-Agent(UA)`：浏览器信息

`Cookie`：服务器接收到的 Cookie 信息

#### 响应首部

`Accept-Ranges`：是否接受字节范围请求

`Age`：推算资源创建经过时间，告知客户端源服务器在多久前创建了响应。字段值的单位为秒

`ETag`：将资源以字符串的形式做唯一标识的方式，服务器会为每份资源分配对应的 `ETag` 的值

`Location`：令客户端重定向至指定的 URI，一般配合 3XX 的响应使用

`Proxy-Authenticate`：代理服务器对客户端的认证信息

`Retry-After`：告知客户端多久之后再发送请求

`Server`：HTTP 服务器的安装信息

`Vary`：代理服务器缓存的管理信息

`WWW-Authenticate`：服务器对客户端的认证信息

`Set-cookie`：  开始状态管理所使用的 Cookie 信息

```
Set-Cookie: status=enable; expires=Tue, 05 Jul 2011 07:26:31 GMT; path=/; domain=.hackr.jp;
```

|   **属性**   |                             说明                             |
| :----------: | :----------------------------------------------------------: |
|  NAME=VALUE  |              赋予 Cookie 的名称和其值（必需项）              |
| expires=DATE |    Cookie的有效期（若不明确指定则默认为浏览器关闭前为止）    |
|  path=PATH   | 将服务器上的文件目录作为Cookie的适用对象（若不指定则默认为文档所在的文件目录） |
| domain=域名  | 作为 Cookie 适用对象的域名 （若不指定则默认为创建 Cookie 的服务器的域名） |
|    Secure    |             仅在 HTTPS 安全通信时才会发送 Cookie             |
|   HttpOnly   |        加以限制，使 Cookie 不能被 JavaScript 脚本访问        |

#### 实体首部

`Allow`：资源可支持的 HTTP 方法，不支持返回 405

`Content-Encoding`：告知客户端服务器对实体的主体部分选用的内容编码方式

`Content-Language`：告知客户端实体主体使用的自然语言

`Content-Length`：实体主体的大小

`Content-Location`：替代对应资源的 URI

`Content-MD5`：一串由 MD5 算法生成的值，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达

`Content-Range`：针对范围请求，返回响应时使用的首部字段，知客户端作为响应返回的实体的哪个部分符合范围请求

`Content-Type`：实体主体的媒体类型

`Expires`：资源失效的日期

缓存服务器在接收到含有首部字段 `Expires` 的响应后，会以缓存来应答请求，在 `Expires` 字段值指定的时间之前，响应的副本会一直被保存。当超过指定的时间后， 缓存服务器在请求发送过来时，会转向源服务器请求资源。

`Last-Modified`：资源最后修改的时间

## HTTP 缓存

http 缓存指的是通过在一段时间内保留已接收到的 web 资源的一个副本，如果在资源的有效时间内，发起了对这个资源的再一次请求，那么浏览器会直接使用缓存的副本，而不是向服务器发起请求。

使用 http 缓存可以有效地提高页面的打开速度，减少不必要的网络带宽的消耗。

web 资源的缓存策略一般由服务器来指定，可以分为两种，分别是强缓存策略和协商缓存策略。

#### 浏览器请求资源时

1. 先判断浏览器有没有缓存，若没缓存则向服务器请求资源

2. 若有缓存，根据 `Cache-Control: max-age` 或是 `Expires` 判断资源是否过期。

   1. 如果资源没过期，则直接从缓存读取（强制缓存），此时在 Network 一栏可以看到资源对应的状态码为 **200（from disk cache）或者是 200 （from memory cache）**

      比如，资源没过期的时候我们打开新的页面，资源会从硬盘缓存中读取（from disk cache）；如果我们此时又刷新页面，资源会从内存缓存中读取（from memory cache）

   2. 如果资源过期了

      1. 查看上次资源的响应是否有Etag头部， 有的话发送请求，请求头为 `If-None-Match`

      2. 没有 `Etag` 的话，看上次资源的响应是否有 `Last-Modified`，有的话发送请求，请求头为 `If-Modified-Since`。

      3. 如果命中了缓存，或者说资源没有发生改变，服务器会发送状态码为 **304（Not Modify）**的响应，告诉浏览器读取缓存中的资源。

         如果未命中缓存，或者说资源发生了改变，服务器会发送状态码为 **200（OK）**的响应，并把资源作为响应的内容发送给浏览器。

## HTTPS

HTTPS = HTTP + SSL(安全套接层)/TLS(安全传输协议)

##### HTTP 缺点

- 通信使用明文（不加密），内容可能会被窃听
- 不验证通信方的身份，内容可能遭遇伪造
- 无法证明报文的完整性

所以 HTTPS = HTTP + 加密 + 认证 + 完整性保护

#### 混合加密机制

HTTPS 采用**共享密钥加密（对称加密）**和**公开密钥加密（非对称加密）**两者混合并用的加密机制

1. 使用公开密钥加密方式安全地交换在稍后的共享密钥加密中要使用的密钥
2. 确保交换的密钥是安全的前提下，使用共享密钥加密方式进行通信

> 公开密钥加密处理起来比共享密钥加密效率要低，所以这样做可以提升效率

#### HTTPS 通信原理

服务器端的公钥和私钥，用来进行非对称加密

客户端生成的随机密钥，用来进行对称加密

1. 客户端发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 版本、加密组件列表。

2. 服务器可进行 SSL 通信时，以 Server Hello 报文作为应答。报文中包含 SSL 版本以及加密组件（从客户端发来的报文中筛选出来的）。

3. 服务器发送 Certificate 报文。报文包含公钥证书。

4. 服务器发送 Server Hello Done 报文通知客户端信息发送结束。

5. 客户端验证证书的合法性，如果验证通过，客户端发送报文 Client Key Exchange 作为应答。报文中包含客户端计算产生随机数字并用服务器证书公钥加密生成的 Pre-master secret 的随机密码串。

   > 此时客户端已经获取全部的计算协商密钥需要的信息：两个明文随机数与自己计算产生的 Pre-master secret，从而计算得到协商密钥

6. 客户端继续发送 Change Cipher Spec 报文。该报文指示服务器之后的通信采用协商密钥进行加密通信。

7. 客户端发送 Finished 报文。报文包含连接至今全部报文的整体校验值，用于服务器握手验证。

8. 服务器接收到 Pre-master secret 后用密钥解密，结合两个随机数生成协商密钥。随后服务器发送 Change Cipher Spec 报文，指示客户端后续的通信都采用协商密钥进行加密通信。

9. 服务器同样发送 Finished 报文。

10. 服务器和客户端 Finished 报文交换后，SSL 连接就算建立完成。

11. 随后开始使用协商密钥进行加密通信，即发送 HTTP 请求和响应。

12. 最后由客户端断开连接。断开连接时发送 close_notify 报文。

#### 中间人攻击

客户端 <=> 中间人 <=> 服务端

1. 服务端向客户端发送公钥，被中间人获取，中间人把自己的公钥给客户端。
2. 客户端用中间人的公钥加密数据发送对称密钥，中间人用自己的私钥解密，再用服务端的公钥加密发送，服务端用自己的私钥解密。
3. 接下来客户端和服务端用对称密钥通信，然而这个密钥中间人也知道，因此能知道密文对应的明文。

中间人攻击是因为服务端发送过来的公钥无法验证是不是真实的公钥，还是伪造的公钥。因此用CA签名的证书（公钥+签名）即可。

## TCP/UDP

TCP 是面向连接的传输层协议，而 UDP 是面向无连接的传输层协议。

TCP 通过三次握手/四次挥手来保障传输，不过因此速度比 UDP 慢。

#### 三次握手

1. Client 给 Server 发送报文，Server 知道自己能接收到 Client 发送的报文

   该报文的 SYN = 1， seq = x

2. Server 给 Client 发送报文，Client 知道自己能接收 Server 发送的报文，知道自己发送的报文能被 Server 接收

   该报文的 SYN = 1, ACK = 1，确认号 = x + 1， seq = y

3. Client 给 Server 发送报文，Server 知道自己发送的报文能被 Client 接收。

   该报文的 ACK = 1，确认号 = y + 1

##### 为什么不是两次握手

主要是为了防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。

#### 四次挥手

1. 若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。
2. B 收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 **CLOSE_WAIT** 状态，表示 A 到 B 的连接已经释放，**不接收 A 发的数据**了。但是因为 **TCP 连接时双向的**，所以 B 仍旧可以发送数据给 A。
3. B 如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进入 **LAST-ACK** 状态。
   - PS：通过延迟确认的技术（通常有时间限制，否则对方会误认为需要重传），可以将第二次和第三次握手合并，延迟 ACK 包的发送。
4. A 收到释放请求后，向 B 发送确认应答，此时 A 进入 **TIME-WAIT** 状态（如果没有 **TIME-WAIT** 状态，若报文因为网络问题没有送达，则服务端不会正常关闭）。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进入 **CLOSED** 状态。当 B 收到确认应答后，也便进入 **CLOSED** 状态。

## IP 协议

<img src="https://raw.githubusercontent.com/jinle0703/img-host/master/blog/ip%E5%8D%8F%E8%AE%AE.png" alt="image-20210109112115972"  />

1. 版本 --- IP 协议的版本，通信双方的版本必须一致，当前主流版本是 4 ，即 IPv4 也有 IPv6
2. 首部位长度 --- 最大数值为 15 ，表示的是 IP 首部长度，IP 首部最大长度为 60 字节
3. 总长度 --- 最大数值为 65535 ，表示的是 IP 数据报总长度（ IP 首部 +IP 数据）
4. TTL --- 表明 IP 数据报文在网络中的寿命，每经过一个设备， TTL 减 1 ，当 TTL=0 时，网络设备必须丢弃该报文
5. 协议 --- 表明 IP 数据所携带的具体数据是什么协议的（ TCP 、 UDP 等）
6. 首部校验和 --- 校验 IP 首部是否有出错

### 转发流程

网络层 ---> 数据链路层 ---> 物理层 ---> 物理层 ---> 数据链路层 ---> 网络层

1. 发送端 A 发出目的地为接收端 D 的 IP 数据报
2. 查询路由表发现下一跳为路由 B
3. 发送端 A 将 IP 数据包交给数据链路层，并告知目的 MAC 地址是 B
4. 数据链路层填充源 MAC 地址 A 和目的 MAC 地址 B
5. 数据链路层通过物理层发送给路由 B
6. 路由 B 的数据链路层接收到数据帧， 把帧数据交给网络层
7. 重复 2、3、4、5 直至接收端 D 收到数据

### ICMP 协议

当 IP 报文协议字段为 **1** 时，表示此报文携带的数据为 ICMP 协议

![image-20210109181919320](https://raw.githubusercontent.com/jinle0703/img-host/master/blog/ICMP%E5%8D%8F%E8%AE%AE.png)

#### 差错报告报文

|     类型值      |     报文类型     | 具体代码 |
| :-------------: | :--------------: | :------: |
| 3（终点不可达） |    网络不可达    |    0     |
| 3（终点不可达） |    主机不可达    |    1     |
|   5（重定向）   |   对网络重定向   |    0     |
|   5（重定向）   |   对主机重定向   |    1     |
|       11        |     传输超时     |    -     |
|       12        |    坏的 IP 头    |    0     |
|       12        | 缺少其他必要参数 |    1     |

#### 询问报文

| 类型值 |     报文类型     | 具体代码 |
| :----: | :--------------: | :------: |
|  0或8  |  回送请求或应答  |    -     |
| 13或14 | 时间戳请求或应答 |    -     |

